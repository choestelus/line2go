// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package line

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type TalkService interface {
	// Parameters:
	//  - ReqSeq
	//  - GroupId
	AcceptGroupInvitation(reqSeq int32, groupId string) (err error)
	// Parameters:
	//  - LocalRev
	//  - Count
	FetchOperations(localRev int64, count int32) (r []*Operation, err error)
	GetAllContactIds() (r []string, err error)
	// Parameters:
	//  - Id
	GetContact(id string) (r *Contact, err error)
	// Parameters:
	//  - Ids
	GetContacts(ids []string) (r []*Contact, err error)
	// Parameters:
	//  - GroupId
	GetGroup(groupId string) (r *Group, err error)
	GetGroupIdsInvited() (r []string, err error)
	GetGroupIdsJoined() (r []string, err error)
	// Parameters:
	//  - GroupIds
	GetGroups(groupIds []string) (r []*Group, err error)
	GetLastOpRevision() (r int64, err error)
	// Parameters:
	//  - Start
	//  - MessageBoxCount
	GetMessageBoxCompactWrapUpList(start int32, messageBoxCount int32) (r *MessageBoxWrapUpList, err error)
	// Parameters:
	//  - MessageBoxId
	//  - EndSeq
	//  - MessagesCount
	GetPreviousMessages(messageBoxId string, endSeq int64, messagesCount int32) (r []*Message, err error)
	// Parameters:
	//  - MessageBoxId
	//  - MessagesCount
	GetRecentMessages(messageBoxId string, messagesCount int32) (r []*Message, err error)
	// Parameters:
	//  - RoomId
	GetRoom(roomId string) (r *Room, err error)
	// Parameters:
	//  - IdentityProvider
	//  - Identifier
	//  - Password
	//  - KeepLoggedIn
	//  - AccessLocation
	//  - SystemName
	//  - Certificate
	LoginWithIdentityCredentialForCertificate(identityProvider IdentityProvider, identifier string, password string, keepLoggedIn bool, accessLocation string, systemName string, certificate string) (r *LoginResult_, err error)
	// Parameters:
	//  - Verifier
	LoginWithVerifierForCertificate(verifier string) (r *LoginResult_, err error)
	// Parameters:
	//  - ReqSeq
	//  - GroupId
	LeaveGroup(reqSeq int32, groupId string) (err error)
	// Parameters:
	//  - ReqSeq
	//  - RoomId
	LeaveRoom(reqSeq int32, roomId string) (err error)
	GetProfile() (r *Profile, err error)
	// Parameters:
	//  - ReqSeq
	//  - GroupId
	RejectGroupInvitation(reqSeq int32, groupId string) (err error)
	// Parameters:
	//  - Seq
	//  - Message
	SendMessage(seq int32, message *Message) (r *Message, err error)
	// Parameters:
	//  - ReqSeq
	//  - Mid
	//  - Flag
	//  - Value
	UpdateContactSetting(reqSeq int32, mid string, flag ContactSetting, value string) (err error)
}

type TalkServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTalkServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *TalkServiceClient {
	return &TalkServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTalkServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *TalkServiceClient {
	return &TalkServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - ReqSeq
//  - GroupId
func (p *TalkServiceClient) AcceptGroupInvitation(reqSeq int32, groupId string) (err error) {
	if err = p.sendAcceptGroupInvitation(reqSeq, groupId); err != nil {
		return
	}
	return p.recvAcceptGroupInvitation()
}

func (p *TalkServiceClient) sendAcceptGroupInvitation(reqSeq int32, groupId string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("acceptGroupInvitation", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AcceptGroupInvitationArgs{
		ReqSeq:  reqSeq,
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvAcceptGroupInvitation() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error8 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error9 error
		error9, err = error8.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error9
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "acceptGroupInvitation failed: out of sequence response")
		return
	}
	result := AcceptGroupInvitationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	return
}

// Parameters:
//  - LocalRev
//  - Count
func (p *TalkServiceClient) FetchOperations(localRev int64, count int32) (r []*Operation, err error) {
	if err = p.sendFetchOperations(localRev, count); err != nil {
		return
	}
	return p.recvFetchOperations()
}

func (p *TalkServiceClient) sendFetchOperations(localRev int64, count int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("fetchOperations", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FetchOperationsArgs{
		LocalRev: localRev,
		Count:    count,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvFetchOperations() (value []*Operation, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error10 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error11 error
		error11, err = error10.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error11
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "fetchOperations failed: out of sequence response")
		return
	}
	result := FetchOperationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

func (p *TalkServiceClient) GetAllContactIds() (r []string, err error) {
	if err = p.sendGetAllContactIds(); err != nil {
		return
	}
	return p.recvGetAllContactIds()
}

func (p *TalkServiceClient) sendGetAllContactIds() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getAllContactIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetAllContactIdsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetAllContactIds() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error12 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error13 error
		error13, err = error12.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error13
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getAllContactIds failed: out of sequence response")
		return
	}
	result := GetAllContactIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Id
func (p *TalkServiceClient) GetContact(id string) (r *Contact, err error) {
	if err = p.sendGetContact(id); err != nil {
		return
	}
	return p.recvGetContact()
}

func (p *TalkServiceClient) sendGetContact(id string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getContact", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetContactArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetContact() (value *Contact, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error14 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error15 error
		error15, err = error14.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error15
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getContact failed: out of sequence response")
		return
	}
	result := GetContactResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Ids
func (p *TalkServiceClient) GetContacts(ids []string) (r []*Contact, err error) {
	if err = p.sendGetContacts(ids); err != nil {
		return
	}
	return p.recvGetContacts()
}

func (p *TalkServiceClient) sendGetContacts(ids []string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getContacts", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetContactsArgs{
		Ids: ids,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetContacts() (value []*Contact, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error16 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error17 error
		error17, err = error16.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error17
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getContacts failed: out of sequence response")
		return
	}
	result := GetContactsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - GroupId
func (p *TalkServiceClient) GetGroup(groupId string) (r *Group, err error) {
	if err = p.sendGetGroup(groupId); err != nil {
		return
	}
	return p.recvGetGroup()
}

func (p *TalkServiceClient) sendGetGroup(groupId string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getGroup", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetGroupArgs{
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetGroup() (value *Group, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error18 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error19 error
		error19, err = error18.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error19
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getGroup failed: out of sequence response")
		return
	}
	result := GetGroupResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

func (p *TalkServiceClient) GetGroupIdsInvited() (r []string, err error) {
	if err = p.sendGetGroupIdsInvited(); err != nil {
		return
	}
	return p.recvGetGroupIdsInvited()
}

func (p *TalkServiceClient) sendGetGroupIdsInvited() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getGroupIdsInvited", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetGroupIdsInvitedArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetGroupIdsInvited() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error20 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error21 error
		error21, err = error20.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error21
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getGroupIdsInvited failed: out of sequence response")
		return
	}
	result := GetGroupIdsInvitedResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

func (p *TalkServiceClient) GetGroupIdsJoined() (r []string, err error) {
	if err = p.sendGetGroupIdsJoined(); err != nil {
		return
	}
	return p.recvGetGroupIdsJoined()
}

func (p *TalkServiceClient) sendGetGroupIdsJoined() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getGroupIdsJoined", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetGroupIdsJoinedArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetGroupIdsJoined() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error22 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error23 error
		error23, err = error22.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error23
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getGroupIdsJoined failed: out of sequence response")
		return
	}
	result := GetGroupIdsJoinedResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - GroupIds
func (p *TalkServiceClient) GetGroups(groupIds []string) (r []*Group, err error) {
	if err = p.sendGetGroups(groupIds); err != nil {
		return
	}
	return p.recvGetGroups()
}

func (p *TalkServiceClient) sendGetGroups(groupIds []string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getGroups", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetGroupsArgs{
		GroupIds: groupIds,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetGroups() (value []*Group, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getGroups failed: out of sequence response")
		return
	}
	result := GetGroupsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

func (p *TalkServiceClient) GetLastOpRevision() (r int64, err error) {
	if err = p.sendGetLastOpRevision(); err != nil {
		return
	}
	return p.recvGetLastOpRevision()
}

func (p *TalkServiceClient) sendGetLastOpRevision() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getLastOpRevision", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetLastOpRevisionArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetLastOpRevision() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getLastOpRevision failed: out of sequence response")
		return
	}
	result := GetLastOpRevisionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Start
//  - MessageBoxCount
func (p *TalkServiceClient) GetMessageBoxCompactWrapUpList(start int32, messageBoxCount int32) (r *MessageBoxWrapUpList, err error) {
	if err = p.sendGetMessageBoxCompactWrapUpList(start, messageBoxCount); err != nil {
		return
	}
	return p.recvGetMessageBoxCompactWrapUpList()
}

func (p *TalkServiceClient) sendGetMessageBoxCompactWrapUpList(start int32, messageBoxCount int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getMessageBoxCompactWrapUpList", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetMessageBoxCompactWrapUpListArgs{
		Start:           start,
		MessageBoxCount: messageBoxCount,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetMessageBoxCompactWrapUpList() (value *MessageBoxWrapUpList, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getMessageBoxCompactWrapUpList failed: out of sequence response")
		return
	}
	result := GetMessageBoxCompactWrapUpListResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - MessageBoxId
//  - EndSeq
//  - MessagesCount
func (p *TalkServiceClient) GetPreviousMessages(messageBoxId string, endSeq int64, messagesCount int32) (r []*Message, err error) {
	if err = p.sendGetPreviousMessages(messageBoxId, endSeq, messagesCount); err != nil {
		return
	}
	return p.recvGetPreviousMessages()
}

func (p *TalkServiceClient) sendGetPreviousMessages(messageBoxId string, endSeq int64, messagesCount int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getPreviousMessages", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetPreviousMessagesArgs{
		MessageBoxId:  messageBoxId,
		EndSeq:        endSeq,
		MessagesCount: messagesCount,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetPreviousMessages() (value []*Message, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getPreviousMessages failed: out of sequence response")
		return
	}
	result := GetPreviousMessagesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - MessageBoxId
//  - MessagesCount
func (p *TalkServiceClient) GetRecentMessages(messageBoxId string, messagesCount int32) (r []*Message, err error) {
	if err = p.sendGetRecentMessages(messageBoxId, messagesCount); err != nil {
		return
	}
	return p.recvGetRecentMessages()
}

func (p *TalkServiceClient) sendGetRecentMessages(messageBoxId string, messagesCount int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRecentMessages", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRecentMessagesArgs{
		MessageBoxId:  messageBoxId,
		MessagesCount: messagesCount,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetRecentMessages() (value []*Message, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRecentMessages failed: out of sequence response")
		return
	}
	result := GetRecentMessagesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - RoomId
func (p *TalkServiceClient) GetRoom(roomId string) (r *Room, err error) {
	if err = p.sendGetRoom(roomId); err != nil {
		return
	}
	return p.recvGetRoom()
}

func (p *TalkServiceClient) sendGetRoom(roomId string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRoom", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRoomArgs{
		RoomId: roomId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetRoom() (value *Room, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRoom failed: out of sequence response")
		return
	}
	result := GetRoomResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - IdentityProvider
//  - Identifier
//  - Password
//  - KeepLoggedIn
//  - AccessLocation
//  - SystemName
//  - Certificate
func (p *TalkServiceClient) LoginWithIdentityCredentialForCertificate(identityProvider IdentityProvider, identifier string, password string, keepLoggedIn bool, accessLocation string, systemName string, certificate string) (r *LoginResult_, err error) {
	if err = p.sendLoginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate); err != nil {
		return
	}
	return p.recvLoginWithIdentityCredentialForCertificate()
}

func (p *TalkServiceClient) sendLoginWithIdentityCredentialForCertificate(identityProvider IdentityProvider, identifier string, password string, keepLoggedIn bool, accessLocation string, systemName string, certificate string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("loginWithIdentityCredentialForCertificate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LoginWithIdentityCredentialForCertificateArgs{
		IdentityProvider: identityProvider,
		Identifier:       identifier,
		Password:         password,
		KeepLoggedIn:     keepLoggedIn,
		AccessLocation:   accessLocation,
		SystemName:       systemName,
		Certificate:      certificate,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvLoginWithIdentityCredentialForCertificate() (value *LoginResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "loginWithIdentityCredentialForCertificate failed: out of sequence response")
		return
	}
	result := LoginWithIdentityCredentialForCertificateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Verifier
func (p *TalkServiceClient) LoginWithVerifierForCertificate(verifier string) (r *LoginResult_, err error) {
	if err = p.sendLoginWithVerifierForCertificate(verifier); err != nil {
		return
	}
	return p.recvLoginWithVerifierForCertificate()
}

func (p *TalkServiceClient) sendLoginWithVerifierForCertificate(verifier string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("loginWithVerifierForCertificate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LoginWithVerifierForCertificateArgs{
		Verifier: verifier,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvLoginWithVerifierForCertificate() (value *LoginResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "loginWithVerifierForCertificate failed: out of sequence response")
		return
	}
	result := LoginWithVerifierForCertificateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - ReqSeq
//  - GroupId
func (p *TalkServiceClient) LeaveGroup(reqSeq int32, groupId string) (err error) {
	if err = p.sendLeaveGroup(reqSeq, groupId); err != nil {
		return
	}
	return p.recvLeaveGroup()
}

func (p *TalkServiceClient) sendLeaveGroup(reqSeq int32, groupId string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("leaveGroup", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LeaveGroupArgs{
		ReqSeq:  reqSeq,
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvLeaveGroup() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "leaveGroup failed: out of sequence response")
		return
	}
	result := LeaveGroupResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	return
}

// Parameters:
//  - ReqSeq
//  - RoomId
func (p *TalkServiceClient) LeaveRoom(reqSeq int32, roomId string) (err error) {
	if err = p.sendLeaveRoom(reqSeq, roomId); err != nil {
		return
	}
	return p.recvLeaveRoom()
}

func (p *TalkServiceClient) sendLeaveRoom(reqSeq int32, roomId string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("leaveRoom", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LeaveRoomArgs{
		ReqSeq: reqSeq,
		RoomId: roomId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvLeaveRoom() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "leaveRoom failed: out of sequence response")
		return
	}
	result := LeaveRoomResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	return
}

func (p *TalkServiceClient) GetProfile() (r *Profile, err error) {
	if err = p.sendGetProfile(); err != nil {
		return
	}
	return p.recvGetProfile()
}

func (p *TalkServiceClient) sendGetProfile() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getProfile", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetProfileArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvGetProfile() (value *Profile, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getProfile failed: out of sequence response")
		return
	}
	result := GetProfileResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - ReqSeq
//  - GroupId
func (p *TalkServiceClient) RejectGroupInvitation(reqSeq int32, groupId string) (err error) {
	if err = p.sendRejectGroupInvitation(reqSeq, groupId); err != nil {
		return
	}
	return p.recvRejectGroupInvitation()
}

func (p *TalkServiceClient) sendRejectGroupInvitation(reqSeq int32, groupId string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("rejectGroupInvitation", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := RejectGroupInvitationArgs{
		ReqSeq:  reqSeq,
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvRejectGroupInvitation() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "rejectGroupInvitation failed: out of sequence response")
		return
	}
	result := RejectGroupInvitationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	return
}

// Parameters:
//  - Seq
//  - Message
func (p *TalkServiceClient) SendMessage(seq int32, message *Message) (r *Message, err error) {
	if err = p.sendSendMessage(seq, message); err != nil {
		return
	}
	return p.recvSendMessage()
}

func (p *TalkServiceClient) sendSendMessage(seq int32, message *Message) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("sendMessage", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SendMessageArgs{
		Seq:     seq,
		Message: message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvSendMessage() (value *Message, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "sendMessage failed: out of sequence response")
		return
	}
	result := SendMessageResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - ReqSeq
//  - Mid
//  - Flag
//  - Value
func (p *TalkServiceClient) UpdateContactSetting(reqSeq int32, mid string, flag ContactSetting, value string) (err error) {
	if err = p.sendUpdateContactSetting(reqSeq, mid, flag, value); err != nil {
		return
	}
	return p.recvUpdateContactSetting()
}

func (p *TalkServiceClient) sendUpdateContactSetting(reqSeq int32, mid string, flag ContactSetting, value string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("updateContactSetting", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UpdateContactSettingArgs{
		ReqSeq: reqSeq,
		Mid:    mid,
		Flag:   flag,
		Value:  value,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TalkServiceClient) recvUpdateContactSetting() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error50 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error51 error
		error51, err = error50.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error51
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "updateContactSetting failed: out of sequence response")
		return
	}
	result := UpdateContactSettingResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	}
	return
}

type TalkServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      TalkService
}

func (p *TalkServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *TalkServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *TalkServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTalkServiceProcessor(handler TalkService) *TalkServiceProcessor {

	self52 := &TalkServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self52.processorMap["acceptGroupInvitation"] = &talkServiceProcessorAcceptGroupInvitation{handler: handler}
	self52.processorMap["fetchOperations"] = &talkServiceProcessorFetchOperations{handler: handler}
	self52.processorMap["getAllContactIds"] = &talkServiceProcessorGetAllContactIds{handler: handler}
	self52.processorMap["getContact"] = &talkServiceProcessorGetContact{handler: handler}
	self52.processorMap["getContacts"] = &talkServiceProcessorGetContacts{handler: handler}
	self52.processorMap["getGroup"] = &talkServiceProcessorGetGroup{handler: handler}
	self52.processorMap["getGroupIdsInvited"] = &talkServiceProcessorGetGroupIdsInvited{handler: handler}
	self52.processorMap["getGroupIdsJoined"] = &talkServiceProcessorGetGroupIdsJoined{handler: handler}
	self52.processorMap["getGroups"] = &talkServiceProcessorGetGroups{handler: handler}
	self52.processorMap["getLastOpRevision"] = &talkServiceProcessorGetLastOpRevision{handler: handler}
	self52.processorMap["getMessageBoxCompactWrapUpList"] = &talkServiceProcessorGetMessageBoxCompactWrapUpList{handler: handler}
	self52.processorMap["getPreviousMessages"] = &talkServiceProcessorGetPreviousMessages{handler: handler}
	self52.processorMap["getRecentMessages"] = &talkServiceProcessorGetRecentMessages{handler: handler}
	self52.processorMap["getRoom"] = &talkServiceProcessorGetRoom{handler: handler}
	self52.processorMap["loginWithIdentityCredentialForCertificate"] = &talkServiceProcessorLoginWithIdentityCredentialForCertificate{handler: handler}
	self52.processorMap["loginWithVerifierForCertificate"] = &talkServiceProcessorLoginWithVerifierForCertificate{handler: handler}
	self52.processorMap["leaveGroup"] = &talkServiceProcessorLeaveGroup{handler: handler}
	self52.processorMap["leaveRoom"] = &talkServiceProcessorLeaveRoom{handler: handler}
	self52.processorMap["getProfile"] = &talkServiceProcessorGetProfile{handler: handler}
	self52.processorMap["rejectGroupInvitation"] = &talkServiceProcessorRejectGroupInvitation{handler: handler}
	self52.processorMap["sendMessage"] = &talkServiceProcessorSendMessage{handler: handler}
	self52.processorMap["updateContactSetting"] = &talkServiceProcessorUpdateContactSetting{handler: handler}
	return self52
}

func (p *TalkServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x53 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x53.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x53

}

type talkServiceProcessorAcceptGroupInvitation struct {
	handler TalkService
}

func (p *talkServiceProcessorAcceptGroupInvitation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AcceptGroupInvitationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("acceptGroupInvitation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AcceptGroupInvitationResult{}
	var err2 error
	if err2 = p.handler.AcceptGroupInvitation(args.ReqSeq, args.GroupId); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing acceptGroupInvitation: "+err2.Error())
			oprot.WriteMessageBegin("acceptGroupInvitation", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("acceptGroupInvitation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorFetchOperations struct {
	handler TalkService
}

func (p *talkServiceProcessorFetchOperations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FetchOperationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("fetchOperations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FetchOperationsResult{}
	var retval []*Operation
	var err2 error
	if retval, err2 = p.handler.FetchOperations(args.LocalRev, args.Count); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchOperations: "+err2.Error())
			oprot.WriteMessageBegin("fetchOperations", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("fetchOperations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetAllContactIds struct {
	handler TalkService
}

func (p *talkServiceProcessorGetAllContactIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetAllContactIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getAllContactIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetAllContactIdsResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.GetAllContactIds(); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAllContactIds: "+err2.Error())
			oprot.WriteMessageBegin("getAllContactIds", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getAllContactIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetContact struct {
	handler TalkService
}

func (p *talkServiceProcessorGetContact) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetContactArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getContact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetContactResult{}
	var retval *Contact
	var err2 error
	if retval, err2 = p.handler.GetContact(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getContact: "+err2.Error())
			oprot.WriteMessageBegin("getContact", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getContact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetContacts struct {
	handler TalkService
}

func (p *talkServiceProcessorGetContacts) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetContactsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getContacts", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetContactsResult{}
	var retval []*Contact
	var err2 error
	if retval, err2 = p.handler.GetContacts(args.Ids); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getContacts: "+err2.Error())
			oprot.WriteMessageBegin("getContacts", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getContacts", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetGroup struct {
	handler TalkService
}

func (p *talkServiceProcessorGetGroup) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetGroupArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetGroupResult{}
	var retval *Group
	var err2 error
	if retval, err2 = p.handler.GetGroup(args.GroupId); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getGroup: "+err2.Error())
			oprot.WriteMessageBegin("getGroup", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getGroup", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetGroupIdsInvited struct {
	handler TalkService
}

func (p *talkServiceProcessorGetGroupIdsInvited) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetGroupIdsInvitedArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getGroupIdsInvited", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetGroupIdsInvitedResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.GetGroupIdsInvited(); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getGroupIdsInvited: "+err2.Error())
			oprot.WriteMessageBegin("getGroupIdsInvited", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getGroupIdsInvited", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetGroupIdsJoined struct {
	handler TalkService
}

func (p *talkServiceProcessorGetGroupIdsJoined) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetGroupIdsJoinedArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getGroupIdsJoined", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetGroupIdsJoinedResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.GetGroupIdsJoined(); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getGroupIdsJoined: "+err2.Error())
			oprot.WriteMessageBegin("getGroupIdsJoined", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getGroupIdsJoined", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetGroups struct {
	handler TalkService
}

func (p *talkServiceProcessorGetGroups) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetGroupsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getGroups", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetGroupsResult{}
	var retval []*Group
	var err2 error
	if retval, err2 = p.handler.GetGroups(args.GroupIds); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getGroups: "+err2.Error())
			oprot.WriteMessageBegin("getGroups", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getGroups", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetLastOpRevision struct {
	handler TalkService
}

func (p *talkServiceProcessorGetLastOpRevision) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetLastOpRevisionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getLastOpRevision", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetLastOpRevisionResult{}
	var retval int64
	var err2 error
	if retval, err2 = p.handler.GetLastOpRevision(); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getLastOpRevision: "+err2.Error())
			oprot.WriteMessageBegin("getLastOpRevision", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getLastOpRevision", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetMessageBoxCompactWrapUpList struct {
	handler TalkService
}

func (p *talkServiceProcessorGetMessageBoxCompactWrapUpList) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetMessageBoxCompactWrapUpListArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getMessageBoxCompactWrapUpList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetMessageBoxCompactWrapUpListResult{}
	var retval *MessageBoxWrapUpList
	var err2 error
	if retval, err2 = p.handler.GetMessageBoxCompactWrapUpList(args.Start, args.MessageBoxCount); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMessageBoxCompactWrapUpList: "+err2.Error())
			oprot.WriteMessageBegin("getMessageBoxCompactWrapUpList", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getMessageBoxCompactWrapUpList", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetPreviousMessages struct {
	handler TalkService
}

func (p *talkServiceProcessorGetPreviousMessages) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetPreviousMessagesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPreviousMessages", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetPreviousMessagesResult{}
	var retval []*Message
	var err2 error
	if retval, err2 = p.handler.GetPreviousMessages(args.MessageBoxId, args.EndSeq, args.MessagesCount); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPreviousMessages: "+err2.Error())
			oprot.WriteMessageBegin("getPreviousMessages", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getPreviousMessages", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetRecentMessages struct {
	handler TalkService
}

func (p *talkServiceProcessorGetRecentMessages) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRecentMessagesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRecentMessages", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRecentMessagesResult{}
	var retval []*Message
	var err2 error
	if retval, err2 = p.handler.GetRecentMessages(args.MessageBoxId, args.MessagesCount); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRecentMessages: "+err2.Error())
			oprot.WriteMessageBegin("getRecentMessages", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRecentMessages", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetRoom struct {
	handler TalkService
}

func (p *talkServiceProcessorGetRoom) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRoomArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRoom", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRoomResult{}
	var retval *Room
	var err2 error
	if retval, err2 = p.handler.GetRoom(args.RoomId); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRoom: "+err2.Error())
			oprot.WriteMessageBegin("getRoom", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRoom", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorLoginWithIdentityCredentialForCertificate struct {
	handler TalkService
}

func (p *talkServiceProcessorLoginWithIdentityCredentialForCertificate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LoginWithIdentityCredentialForCertificateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("loginWithIdentityCredentialForCertificate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LoginWithIdentityCredentialForCertificateResult{}
	var retval *LoginResult_
	var err2 error
	if retval, err2 = p.handler.LoginWithIdentityCredentialForCertificate(args.IdentityProvider, args.Identifier, args.Password, args.KeepLoggedIn, args.AccessLocation, args.SystemName, args.Certificate); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing loginWithIdentityCredentialForCertificate: "+err2.Error())
			oprot.WriteMessageBegin("loginWithIdentityCredentialForCertificate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("loginWithIdentityCredentialForCertificate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorLoginWithVerifierForCertificate struct {
	handler TalkService
}

func (p *talkServiceProcessorLoginWithVerifierForCertificate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LoginWithVerifierForCertificateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("loginWithVerifierForCertificate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LoginWithVerifierForCertificateResult{}
	var retval *LoginResult_
	var err2 error
	if retval, err2 = p.handler.LoginWithVerifierForCertificate(args.Verifier); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing loginWithVerifierForCertificate: "+err2.Error())
			oprot.WriteMessageBegin("loginWithVerifierForCertificate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("loginWithVerifierForCertificate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorLeaveGroup struct {
	handler TalkService
}

func (p *talkServiceProcessorLeaveGroup) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LeaveGroupArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("leaveGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LeaveGroupResult{}
	var err2 error
	if err2 = p.handler.LeaveGroup(args.ReqSeq, args.GroupId); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing leaveGroup: "+err2.Error())
			oprot.WriteMessageBegin("leaveGroup", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("leaveGroup", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorLeaveRoom struct {
	handler TalkService
}

func (p *talkServiceProcessorLeaveRoom) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LeaveRoomArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("leaveRoom", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LeaveRoomResult{}
	var err2 error
	if err2 = p.handler.LeaveRoom(args.ReqSeq, args.RoomId); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing leaveRoom: "+err2.Error())
			oprot.WriteMessageBegin("leaveRoom", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("leaveRoom", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorGetProfile struct {
	handler TalkService
}

func (p *talkServiceProcessorGetProfile) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetProfileArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getProfile", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetProfileResult{}
	var retval *Profile
	var err2 error
	if retval, err2 = p.handler.GetProfile(); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getProfile: "+err2.Error())
			oprot.WriteMessageBegin("getProfile", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getProfile", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorRejectGroupInvitation struct {
	handler TalkService
}

func (p *talkServiceProcessorRejectGroupInvitation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RejectGroupInvitationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("rejectGroupInvitation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := RejectGroupInvitationResult{}
	var err2 error
	if err2 = p.handler.RejectGroupInvitation(args.ReqSeq, args.GroupId); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing rejectGroupInvitation: "+err2.Error())
			oprot.WriteMessageBegin("rejectGroupInvitation", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("rejectGroupInvitation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorSendMessage struct {
	handler TalkService
}

func (p *talkServiceProcessorSendMessage) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SendMessageArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("sendMessage", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SendMessageResult{}
	var retval *Message
	var err2 error
	if retval, err2 = p.handler.SendMessage(args.Seq, args.Message); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sendMessage: "+err2.Error())
			oprot.WriteMessageBegin("sendMessage", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("sendMessage", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type talkServiceProcessorUpdateContactSetting struct {
	handler TalkService
}

func (p *talkServiceProcessorUpdateContactSetting) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UpdateContactSettingArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("updateContactSetting", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UpdateContactSettingResult{}
	var err2 error
	if err2 = p.handler.UpdateContactSetting(args.ReqSeq, args.Mid, args.Flag, args.Value); err2 != nil {
		switch v := err2.(type) {
		case *TalkException:
			result.E = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateContactSetting: "+err2.Error())
			oprot.WriteMessageBegin("updateContactSetting", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("updateContactSetting", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type AcceptGroupInvitationArgs struct {
	ReqSeq  int32  `thrift:"reqSeq,1" json:"reqSeq"`
	GroupId string `thrift:"groupId,2" json:"groupId"`
}

func NewAcceptGroupInvitationArgs() *AcceptGroupInvitationArgs {
	return &AcceptGroupInvitationArgs{}
}

func (p *AcceptGroupInvitationArgs) GetReqSeq() int32 {
	return p.ReqSeq
}

func (p *AcceptGroupInvitationArgs) GetGroupId() string {
	return p.GroupId
}
func (p *AcceptGroupInvitationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AcceptGroupInvitationArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ReqSeq = v
	}
	return nil
}

func (p *AcceptGroupInvitationArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *AcceptGroupInvitationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("acceptGroupInvitation_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AcceptGroupInvitationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reqSeq", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:reqSeq: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ReqSeq)); err != nil {
		return fmt.Errorf("%T.reqSeq (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:reqSeq: %s", p, err)
	}
	return err
}

func (p *AcceptGroupInvitationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:groupId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:groupId: %s", p, err)
	}
	return err
}

func (p *AcceptGroupInvitationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AcceptGroupInvitationArgs(%+v)", *p)
}

type AcceptGroupInvitationResult struct {
	E *TalkException `thrift:"e,1" json:"e"`
}

func NewAcceptGroupInvitationResult() *AcceptGroupInvitationResult {
	return &AcceptGroupInvitationResult{}
}

var AcceptGroupInvitationResult_E_DEFAULT *TalkException

func (p *AcceptGroupInvitationResult) GetE() *TalkException {
	if !p.IsSetE() {
		return AcceptGroupInvitationResult_E_DEFAULT
	}
	return p.E
}
func (p *AcceptGroupInvitationResult) IsSetE() bool {
	return p.E != nil
}

func (p *AcceptGroupInvitationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AcceptGroupInvitationResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *AcceptGroupInvitationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("acceptGroupInvitation_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AcceptGroupInvitationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AcceptGroupInvitationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AcceptGroupInvitationResult(%+v)", *p)
}

type FetchOperationsArgs struct {
	// unused field # 1
	LocalRev int64 `thrift:"localRev,2" json:"localRev"`
	Count    int32 `thrift:"count,3" json:"count"`
}

func NewFetchOperationsArgs() *FetchOperationsArgs {
	return &FetchOperationsArgs{}
}

func (p *FetchOperationsArgs) GetLocalRev() int64 {
	return p.LocalRev
}

func (p *FetchOperationsArgs) GetCount() int32 {
	return p.Count
}
func (p *FetchOperationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FetchOperationsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.LocalRev = v
	}
	return nil
}

func (p *FetchOperationsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *FetchOperationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetchOperations_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FetchOperationsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("localRev", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:localRev: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.LocalRev)); err != nil {
		return fmt.Errorf("%T.localRev (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:localRev: %s", p, err)
	}
	return err
}

func (p *FetchOperationsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:count: %s", p, err)
	}
	return err
}

func (p *FetchOperationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchOperationsArgs(%+v)", *p)
}

type FetchOperationsResult struct {
	Success []*Operation   `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewFetchOperationsResult() *FetchOperationsResult {
	return &FetchOperationsResult{}
}

var FetchOperationsResult_Success_DEFAULT []*Operation

func (p *FetchOperationsResult) GetSuccess() []*Operation {
	return p.Success
}

var FetchOperationsResult_E_DEFAULT *TalkException

func (p *FetchOperationsResult) GetE() *TalkException {
	if !p.IsSetE() {
		return FetchOperationsResult_E_DEFAULT
	}
	return p.E
}
func (p *FetchOperationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FetchOperationsResult) IsSetE() bool {
	return p.E != nil
}

func (p *FetchOperationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FetchOperationsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Operation, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem54 := &Operation{}
		if err := _elem54.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem54, err)
		}
		p.Success = append(p.Success, _elem54)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *FetchOperationsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *FetchOperationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetchOperations_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FetchOperationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FetchOperationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FetchOperationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchOperationsResult(%+v)", *p)
}

type GetAllContactIdsArgs struct {
}

func NewGetAllContactIdsArgs() *GetAllContactIdsArgs {
	return &GetAllContactIdsArgs{}
}

func (p *GetAllContactIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetAllContactIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAllContactIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetAllContactIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetAllContactIdsArgs(%+v)", *p)
}

type GetAllContactIdsResult struct {
	Success []string       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetAllContactIdsResult() *GetAllContactIdsResult {
	return &GetAllContactIdsResult{}
}

var GetAllContactIdsResult_Success_DEFAULT []string

func (p *GetAllContactIdsResult) GetSuccess() []string {
	return p.Success
}

var GetAllContactIdsResult_E_DEFAULT *TalkException

func (p *GetAllContactIdsResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetAllContactIdsResult_E_DEFAULT
	}
	return p.E
}
func (p *GetAllContactIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetAllContactIdsResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetAllContactIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetAllContactIdsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem55 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem55 = v
		}
		p.Success = append(p.Success, _elem55)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetAllContactIdsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetAllContactIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAllContactIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetAllContactIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetAllContactIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetAllContactIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetAllContactIdsResult(%+v)", *p)
}

type GetContactArgs struct {
	// unused field # 1
	Id string `thrift:"id,2" json:"id"`
}

func NewGetContactArgs() *GetContactArgs {
	return &GetContactArgs{}
}

func (p *GetContactArgs) GetId() string {
	return p.Id
}
func (p *GetContactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetContactArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Id = v
	}
	return nil
}

func (p *GetContactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getContact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetContactArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:id: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Id)); err != nil {
		return fmt.Errorf("%T.id (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:id: %s", p, err)
	}
	return err
}

func (p *GetContactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetContactArgs(%+v)", *p)
}

type GetContactResult struct {
	Success *Contact       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetContactResult() *GetContactResult {
	return &GetContactResult{}
}

var GetContactResult_Success_DEFAULT *Contact

func (p *GetContactResult) GetSuccess() *Contact {
	if !p.IsSetSuccess() {
		return GetContactResult_Success_DEFAULT
	}
	return p.Success
}

var GetContactResult_E_DEFAULT *TalkException

func (p *GetContactResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetContactResult_E_DEFAULT
	}
	return p.E
}
func (p *GetContactResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetContactResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetContactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetContactResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Contact{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetContactResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetContactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getContact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetContactResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetContactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetContactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetContactResult(%+v)", *p)
}

type GetContactsArgs struct {
	// unused field # 1
	Ids []string `thrift:"ids,2" json:"ids"`
}

func NewGetContactsArgs() *GetContactsArgs {
	return &GetContactsArgs{}
}

func (p *GetContactsArgs) GetIds() []string {
	return p.Ids
}
func (p *GetContactsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetContactsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Ids = tSlice
	for i := 0; i < size; i++ {
		var _elem56 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem56 = v
		}
		p.Ids = append(p.Ids, _elem56)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetContactsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getContacts_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetContactsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ids", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:ids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Ids)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Ids {
		if err := oprot.WriteString(string(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:ids: %s", p, err)
	}
	return err
}

func (p *GetContactsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetContactsArgs(%+v)", *p)
}

type GetContactsResult struct {
	Success []*Contact     `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetContactsResult() *GetContactsResult {
	return &GetContactsResult{}
}

var GetContactsResult_Success_DEFAULT []*Contact

func (p *GetContactsResult) GetSuccess() []*Contact {
	return p.Success
}

var GetContactsResult_E_DEFAULT *TalkException

func (p *GetContactsResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetContactsResult_E_DEFAULT
	}
	return p.E
}
func (p *GetContactsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetContactsResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetContactsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetContactsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Contact, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem57 := &Contact{}
		if err := _elem57.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem57, err)
		}
		p.Success = append(p.Success, _elem57)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetContactsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetContactsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getContacts_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetContactsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetContactsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetContactsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetContactsResult(%+v)", *p)
}

type GetGroupArgs struct {
	// unused field # 1
	GroupId string `thrift:"groupId,2" json:"groupId"`
}

func NewGetGroupArgs() *GetGroupArgs {
	return &GetGroupArgs{}
}

func (p *GetGroupArgs) GetGroupId() string {
	return p.GroupId
}
func (p *GetGroupArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *GetGroupArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroup_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:groupId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:groupId: %s", p, err)
	}
	return err
}

func (p *GetGroupArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupArgs(%+v)", *p)
}

type GetGroupResult struct {
	Success *Group         `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetGroupResult() *GetGroupResult {
	return &GetGroupResult{}
}

var GetGroupResult_Success_DEFAULT *Group

func (p *GetGroupResult) GetSuccess() *Group {
	if !p.IsSetSuccess() {
		return GetGroupResult_Success_DEFAULT
	}
	return p.Success
}

var GetGroupResult_E_DEFAULT *TalkException

func (p *GetGroupResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetGroupResult_E_DEFAULT
	}
	return p.E
}
func (p *GetGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetGroupResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetGroupResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Group{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetGroupResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetGroupResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroup_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupResult(%+v)", *p)
}

type GetGroupIdsInvitedArgs struct {
}

func NewGetGroupIdsInvitedArgs() *GetGroupIdsInvitedArgs {
	return &GetGroupIdsInvitedArgs{}
}

func (p *GetGroupIdsInvitedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupIdsInvitedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroupIdsInvited_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupIdsInvitedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupIdsInvitedArgs(%+v)", *p)
}

type GetGroupIdsInvitedResult struct {
	Success []string       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetGroupIdsInvitedResult() *GetGroupIdsInvitedResult {
	return &GetGroupIdsInvitedResult{}
}

var GetGroupIdsInvitedResult_Success_DEFAULT []string

func (p *GetGroupIdsInvitedResult) GetSuccess() []string {
	return p.Success
}

var GetGroupIdsInvitedResult_E_DEFAULT *TalkException

func (p *GetGroupIdsInvitedResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetGroupIdsInvitedResult_E_DEFAULT
	}
	return p.E
}
func (p *GetGroupIdsInvitedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetGroupIdsInvitedResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetGroupIdsInvitedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupIdsInvitedResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem58 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem58 = v
		}
		p.Success = append(p.Success, _elem58)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetGroupIdsInvitedResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetGroupIdsInvitedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroupIdsInvited_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupIdsInvitedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupIdsInvitedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupIdsInvitedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupIdsInvitedResult(%+v)", *p)
}

type GetGroupIdsJoinedArgs struct {
}

func NewGetGroupIdsJoinedArgs() *GetGroupIdsJoinedArgs {
	return &GetGroupIdsJoinedArgs{}
}

func (p *GetGroupIdsJoinedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupIdsJoinedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroupIdsJoined_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupIdsJoinedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupIdsJoinedArgs(%+v)", *p)
}

type GetGroupIdsJoinedResult struct {
	Success []string       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetGroupIdsJoinedResult() *GetGroupIdsJoinedResult {
	return &GetGroupIdsJoinedResult{}
}

var GetGroupIdsJoinedResult_Success_DEFAULT []string

func (p *GetGroupIdsJoinedResult) GetSuccess() []string {
	return p.Success
}

var GetGroupIdsJoinedResult_E_DEFAULT *TalkException

func (p *GetGroupIdsJoinedResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetGroupIdsJoinedResult_E_DEFAULT
	}
	return p.E
}
func (p *GetGroupIdsJoinedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetGroupIdsJoinedResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetGroupIdsJoinedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupIdsJoinedResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem59 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem59 = v
		}
		p.Success = append(p.Success, _elem59)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetGroupIdsJoinedResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetGroupIdsJoinedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroupIdsJoined_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupIdsJoinedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupIdsJoinedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupIdsJoinedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupIdsJoinedResult(%+v)", *p)
}

type GetGroupsArgs struct {
	// unused field # 1
	GroupIds []string `thrift:"groupIds,2" json:"groupIds"`
}

func NewGetGroupsArgs() *GetGroupsArgs {
	return &GetGroupsArgs{}
}

func (p *GetGroupsArgs) GetGroupIds() []string {
	return p.GroupIds
}
func (p *GetGroupsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.GroupIds = tSlice
	for i := 0; i < size; i++ {
		var _elem60 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem60 = v
		}
		p.GroupIds = append(p.GroupIds, _elem60)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetGroupsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroups_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupIds", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:groupIds: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.GroupIds)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.GroupIds {
		if err := oprot.WriteString(string(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:groupIds: %s", p, err)
	}
	return err
}

func (p *GetGroupsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupsArgs(%+v)", *p)
}

type GetGroupsResult struct {
	Success []*Group       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetGroupsResult() *GetGroupsResult {
	return &GetGroupsResult{}
}

var GetGroupsResult_Success_DEFAULT []*Group

func (p *GetGroupsResult) GetSuccess() []*Group {
	return p.Success
}

var GetGroupsResult_E_DEFAULT *TalkException

func (p *GetGroupsResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetGroupsResult_E_DEFAULT
	}
	return p.E
}
func (p *GetGroupsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetGroupsResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetGroupsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Group, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem61 := &Group{}
		if err := _elem61.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem61, err)
		}
		p.Success = append(p.Success, _elem61)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetGroupsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetGroupsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGroups_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupsResult(%+v)", *p)
}

type GetLastOpRevisionArgs struct {
}

func NewGetLastOpRevisionArgs() *GetLastOpRevisionArgs {
	return &GetLastOpRevisionArgs{}
}

func (p *GetLastOpRevisionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLastOpRevisionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getLastOpRevision_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLastOpRevisionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLastOpRevisionArgs(%+v)", *p)
}

type GetLastOpRevisionResult struct {
	Success *int64         `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetLastOpRevisionResult() *GetLastOpRevisionResult {
	return &GetLastOpRevisionResult{}
}

var GetLastOpRevisionResult_Success_DEFAULT int64

func (p *GetLastOpRevisionResult) GetSuccess() int64 {
	if !p.IsSetSuccess() {
		return GetLastOpRevisionResult_Success_DEFAULT
	}
	return *p.Success
}

var GetLastOpRevisionResult_E_DEFAULT *TalkException

func (p *GetLastOpRevisionResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetLastOpRevisionResult_E_DEFAULT
	}
	return p.E
}
func (p *GetLastOpRevisionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetLastOpRevisionResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetLastOpRevisionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLastOpRevisionResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetLastOpRevisionResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetLastOpRevisionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getLastOpRevision_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLastOpRevisionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetLastOpRevisionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetLastOpRevisionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLastOpRevisionResult(%+v)", *p)
}

type GetMessageBoxCompactWrapUpListArgs struct {
	// unused field # 1
	Start           int32 `thrift:"start,2" json:"start"`
	MessageBoxCount int32 `thrift:"messageBoxCount,3" json:"messageBoxCount"`
}

func NewGetMessageBoxCompactWrapUpListArgs() *GetMessageBoxCompactWrapUpListArgs {
	return &GetMessageBoxCompactWrapUpListArgs{}
}

func (p *GetMessageBoxCompactWrapUpListArgs) GetStart() int32 {
	return p.Start
}

func (p *GetMessageBoxCompactWrapUpListArgs) GetMessageBoxCount() int32 {
	return p.MessageBoxCount
}
func (p *GetMessageBoxCompactWrapUpListArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Start = v
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.MessageBoxCount = v
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMessageBoxCompactWrapUpList_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Start)); err != nil {
		return fmt.Errorf("%T.start (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start: %s", p, err)
	}
	return err
}

func (p *GetMessageBoxCompactWrapUpListArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("messageBoxCount", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:messageBoxCount: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.MessageBoxCount)); err != nil {
		return fmt.Errorf("%T.messageBoxCount (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:messageBoxCount: %s", p, err)
	}
	return err
}

func (p *GetMessageBoxCompactWrapUpListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMessageBoxCompactWrapUpListArgs(%+v)", *p)
}

type GetMessageBoxCompactWrapUpListResult struct {
	Success *MessageBoxWrapUpList `thrift:"success,0" json:"success"`
	E       *TalkException        `thrift:"e,1" json:"e"`
}

func NewGetMessageBoxCompactWrapUpListResult() *GetMessageBoxCompactWrapUpListResult {
	return &GetMessageBoxCompactWrapUpListResult{}
}

var GetMessageBoxCompactWrapUpListResult_Success_DEFAULT *MessageBoxWrapUpList

func (p *GetMessageBoxCompactWrapUpListResult) GetSuccess() *MessageBoxWrapUpList {
	if !p.IsSetSuccess() {
		return GetMessageBoxCompactWrapUpListResult_Success_DEFAULT
	}
	return p.Success
}

var GetMessageBoxCompactWrapUpListResult_E_DEFAULT *TalkException

func (p *GetMessageBoxCompactWrapUpListResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetMessageBoxCompactWrapUpListResult_E_DEFAULT
	}
	return p.E
}
func (p *GetMessageBoxCompactWrapUpListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetMessageBoxCompactWrapUpListResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetMessageBoxCompactWrapUpListResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &MessageBoxWrapUpList{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMessageBoxCompactWrapUpList_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMessageBoxCompactWrapUpListResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetMessageBoxCompactWrapUpListResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetMessageBoxCompactWrapUpListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMessageBoxCompactWrapUpListResult(%+v)", *p)
}

type GetPreviousMessagesArgs struct {
	// unused field # 1
	MessageBoxId  string `thrift:"messageBoxId,2" json:"messageBoxId"`
	EndSeq        int64  `thrift:"endSeq,3" json:"endSeq"`
	MessagesCount int32  `thrift:"messagesCount,4" json:"messagesCount"`
}

func NewGetPreviousMessagesArgs() *GetPreviousMessagesArgs {
	return &GetPreviousMessagesArgs{}
}

func (p *GetPreviousMessagesArgs) GetMessageBoxId() string {
	return p.MessageBoxId
}

func (p *GetPreviousMessagesArgs) GetEndSeq() int64 {
	return p.EndSeq
}

func (p *GetPreviousMessagesArgs) GetMessagesCount() int32 {
	return p.MessagesCount
}
func (p *GetPreviousMessagesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPreviousMessagesArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.MessageBoxId = v
	}
	return nil
}

func (p *GetPreviousMessagesArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.EndSeq = v
	}
	return nil
}

func (p *GetPreviousMessagesArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.MessagesCount = v
	}
	return nil
}

func (p *GetPreviousMessagesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPreviousMessages_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPreviousMessagesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("messageBoxId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:messageBoxId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.MessageBoxId)); err != nil {
		return fmt.Errorf("%T.messageBoxId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:messageBoxId: %s", p, err)
	}
	return err
}

func (p *GetPreviousMessagesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("endSeq", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:endSeq: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.EndSeq)); err != nil {
		return fmt.Errorf("%T.endSeq (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:endSeq: %s", p, err)
	}
	return err
}

func (p *GetPreviousMessagesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("messagesCount", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:messagesCount: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.MessagesCount)); err != nil {
		return fmt.Errorf("%T.messagesCount (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:messagesCount: %s", p, err)
	}
	return err
}

func (p *GetPreviousMessagesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPreviousMessagesArgs(%+v)", *p)
}

type GetPreviousMessagesResult struct {
	Success []*Message     `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetPreviousMessagesResult() *GetPreviousMessagesResult {
	return &GetPreviousMessagesResult{}
}

var GetPreviousMessagesResult_Success_DEFAULT []*Message

func (p *GetPreviousMessagesResult) GetSuccess() []*Message {
	return p.Success
}

var GetPreviousMessagesResult_E_DEFAULT *TalkException

func (p *GetPreviousMessagesResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetPreviousMessagesResult_E_DEFAULT
	}
	return p.E
}
func (p *GetPreviousMessagesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPreviousMessagesResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetPreviousMessagesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPreviousMessagesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Message, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem62 := &Message{}
		if err := _elem62.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem62, err)
		}
		p.Success = append(p.Success, _elem62)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetPreviousMessagesResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetPreviousMessagesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPreviousMessages_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPreviousMessagesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPreviousMessagesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetPreviousMessagesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPreviousMessagesResult(%+v)", *p)
}

type GetRecentMessagesArgs struct {
	// unused field # 1
	MessageBoxId  string `thrift:"messageBoxId,2" json:"messageBoxId"`
	MessagesCount int32  `thrift:"messagesCount,3" json:"messagesCount"`
}

func NewGetRecentMessagesArgs() *GetRecentMessagesArgs {
	return &GetRecentMessagesArgs{}
}

func (p *GetRecentMessagesArgs) GetMessageBoxId() string {
	return p.MessageBoxId
}

func (p *GetRecentMessagesArgs) GetMessagesCount() int32 {
	return p.MessagesCount
}
func (p *GetRecentMessagesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRecentMessagesArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.MessageBoxId = v
	}
	return nil
}

func (p *GetRecentMessagesArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.MessagesCount = v
	}
	return nil
}

func (p *GetRecentMessagesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRecentMessages_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRecentMessagesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("messageBoxId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:messageBoxId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.MessageBoxId)); err != nil {
		return fmt.Errorf("%T.messageBoxId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:messageBoxId: %s", p, err)
	}
	return err
}

func (p *GetRecentMessagesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("messagesCount", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:messagesCount: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.MessagesCount)); err != nil {
		return fmt.Errorf("%T.messagesCount (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:messagesCount: %s", p, err)
	}
	return err
}

func (p *GetRecentMessagesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRecentMessagesArgs(%+v)", *p)
}

type GetRecentMessagesResult struct {
	Success []*Message     `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetRecentMessagesResult() *GetRecentMessagesResult {
	return &GetRecentMessagesResult{}
}

var GetRecentMessagesResult_Success_DEFAULT []*Message

func (p *GetRecentMessagesResult) GetSuccess() []*Message {
	return p.Success
}

var GetRecentMessagesResult_E_DEFAULT *TalkException

func (p *GetRecentMessagesResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetRecentMessagesResult_E_DEFAULT
	}
	return p.E
}
func (p *GetRecentMessagesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRecentMessagesResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetRecentMessagesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRecentMessagesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Message, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem63 := &Message{}
		if err := _elem63.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem63, err)
		}
		p.Success = append(p.Success, _elem63)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRecentMessagesResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetRecentMessagesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRecentMessages_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRecentMessagesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRecentMessagesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetRecentMessagesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRecentMessagesResult(%+v)", *p)
}

type GetRoomArgs struct {
	// unused field # 1
	RoomId string `thrift:"roomId,2" json:"roomId"`
}

func NewGetRoomArgs() *GetRoomArgs {
	return &GetRoomArgs{}
}

func (p *GetRoomArgs) GetRoomId() string {
	return p.RoomId
}
func (p *GetRoomArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRoomArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.RoomId = v
	}
	return nil
}

func (p *GetRoomArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRoom_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRoomArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("roomId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:roomId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.RoomId)); err != nil {
		return fmt.Errorf("%T.roomId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:roomId: %s", p, err)
	}
	return err
}

func (p *GetRoomArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRoomArgs(%+v)", *p)
}

type GetRoomResult struct {
	Success *Room          `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetRoomResult() *GetRoomResult {
	return &GetRoomResult{}
}

var GetRoomResult_Success_DEFAULT *Room

func (p *GetRoomResult) GetSuccess() *Room {
	if !p.IsSetSuccess() {
		return GetRoomResult_Success_DEFAULT
	}
	return p.Success
}

var GetRoomResult_E_DEFAULT *TalkException

func (p *GetRoomResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetRoomResult_E_DEFAULT
	}
	return p.E
}
func (p *GetRoomResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRoomResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetRoomResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRoomResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Room{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetRoomResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetRoomResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRoom_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRoomResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRoomResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetRoomResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRoomResult(%+v)", *p)
}

type LoginWithIdentityCredentialForCertificateArgs struct {
	// unused fields # 1 to 2
	Identifier       string           `thrift:"identifier,3" json:"identifier"`
	Password         string           `thrift:"password,4" json:"password"`
	KeepLoggedIn     bool             `thrift:"keepLoggedIn,5" json:"keepLoggedIn"`
	AccessLocation   string           `thrift:"accessLocation,6" json:"accessLocation"`
	SystemName       string           `thrift:"systemName,7" json:"systemName"`
	IdentityProvider IdentityProvider `thrift:"identityProvider,8" json:"identityProvider"`
	Certificate      string           `thrift:"certificate,9" json:"certificate"`
}

func NewLoginWithIdentityCredentialForCertificateArgs() *LoginWithIdentityCredentialForCertificateArgs {
	return &LoginWithIdentityCredentialForCertificateArgs{}
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetIdentityProvider() IdentityProvider {
	return p.IdentityProvider
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetIdentifier() string {
	return p.Identifier
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetPassword() string {
	return p.Password
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetKeepLoggedIn() bool {
	return p.KeepLoggedIn
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetAccessLocation() string {
	return p.AccessLocation
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetSystemName() string {
	return p.SystemName
}

func (p *LoginWithIdentityCredentialForCertificateArgs) GetCertificate() string {
	return p.Certificate
}
func (p *LoginWithIdentityCredentialForCertificateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 8:
			if err := p.ReadField8(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.ReadField7(iprot); err != nil {
				return err
			}
		case 9:
			if err := p.ReadField9(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 8: %s", err)
	} else {
		temp := IdentityProvider(v)
		p.IdentityProvider = temp
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Identifier = v
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Password = v
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.KeepLoggedIn = v
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.AccessLocation = v
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 7: %s", err)
	} else {
		p.SystemName = v
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) ReadField9(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 9: %s", err)
	} else {
		p.Certificate = v
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("loginWithIdentityCredentialForCertificate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := p.writeField8(oprot); err != nil {
		return err
	}
	if err := p.writeField9(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("identifier", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:identifier: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Identifier)); err != nil {
		return fmt.Errorf("%T.identifier (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:identifier: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:password: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return fmt.Errorf("%T.password (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:password: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keepLoggedIn", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:keepLoggedIn: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.KeepLoggedIn)); err != nil {
		return fmt.Errorf("%T.keepLoggedIn (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:keepLoggedIn: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("accessLocation", thrift.STRING, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:accessLocation: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AccessLocation)); err != nil {
		return fmt.Errorf("%T.accessLocation (6) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:accessLocation: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("systemName", thrift.STRING, 7); err != nil {
		return fmt.Errorf("%T write field begin error 7:systemName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.SystemName)); err != nil {
		return fmt.Errorf("%T.systemName (7) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 7:systemName: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField8(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("identityProvider", thrift.I32, 8); err != nil {
		return fmt.Errorf("%T write field begin error 8:identityProvider: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.IdentityProvider)); err != nil {
		return fmt.Errorf("%T.identityProvider (8) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 8:identityProvider: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) writeField9(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("certificate", thrift.STRING, 9); err != nil {
		return fmt.Errorf("%T write field begin error 9:certificate: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Certificate)); err != nil {
		return fmt.Errorf("%T.certificate (9) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 9:certificate: %s", p, err)
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginWithIdentityCredentialForCertificateArgs(%+v)", *p)
}

type LoginWithIdentityCredentialForCertificateResult struct {
	Success *LoginResult_  `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewLoginWithIdentityCredentialForCertificateResult() *LoginWithIdentityCredentialForCertificateResult {
	return &LoginWithIdentityCredentialForCertificateResult{}
}

var LoginWithIdentityCredentialForCertificateResult_Success_DEFAULT *LoginResult_

func (p *LoginWithIdentityCredentialForCertificateResult) GetSuccess() *LoginResult_ {
	if !p.IsSetSuccess() {
		return LoginWithIdentityCredentialForCertificateResult_Success_DEFAULT
	}
	return p.Success
}

var LoginWithIdentityCredentialForCertificateResult_E_DEFAULT *TalkException

func (p *LoginWithIdentityCredentialForCertificateResult) GetE() *TalkException {
	if !p.IsSetE() {
		return LoginWithIdentityCredentialForCertificateResult_E_DEFAULT
	}
	return p.E
}
func (p *LoginWithIdentityCredentialForCertificateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LoginWithIdentityCredentialForCertificateResult) IsSetE() bool {
	return p.E != nil
}

func (p *LoginWithIdentityCredentialForCertificateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &LoginResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("loginWithIdentityCredentialForCertificate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginWithIdentityCredentialForCertificateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *LoginWithIdentityCredentialForCertificateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginWithIdentityCredentialForCertificateResult(%+v)", *p)
}

type LoginWithVerifierForCertificateArgs struct {
	// unused fields # 1 to 2
	Verifier string `thrift:"verifier,3" json:"verifier"`
}

func NewLoginWithVerifierForCertificateArgs() *LoginWithVerifierForCertificateArgs {
	return &LoginWithVerifierForCertificateArgs{}
}

func (p *LoginWithVerifierForCertificateArgs) GetVerifier() string {
	return p.Verifier
}
func (p *LoginWithVerifierForCertificateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginWithVerifierForCertificateArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Verifier = v
	}
	return nil
}

func (p *LoginWithVerifierForCertificateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("loginWithVerifierForCertificate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginWithVerifierForCertificateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("verifier", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:verifier: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Verifier)); err != nil {
		return fmt.Errorf("%T.verifier (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:verifier: %s", p, err)
	}
	return err
}

func (p *LoginWithVerifierForCertificateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginWithVerifierForCertificateArgs(%+v)", *p)
}

type LoginWithVerifierForCertificateResult struct {
	Success *LoginResult_  `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewLoginWithVerifierForCertificateResult() *LoginWithVerifierForCertificateResult {
	return &LoginWithVerifierForCertificateResult{}
}

var LoginWithVerifierForCertificateResult_Success_DEFAULT *LoginResult_

func (p *LoginWithVerifierForCertificateResult) GetSuccess() *LoginResult_ {
	if !p.IsSetSuccess() {
		return LoginWithVerifierForCertificateResult_Success_DEFAULT
	}
	return p.Success
}

var LoginWithVerifierForCertificateResult_E_DEFAULT *TalkException

func (p *LoginWithVerifierForCertificateResult) GetE() *TalkException {
	if !p.IsSetE() {
		return LoginWithVerifierForCertificateResult_E_DEFAULT
	}
	return p.E
}
func (p *LoginWithVerifierForCertificateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LoginWithVerifierForCertificateResult) IsSetE() bool {
	return p.E != nil
}

func (p *LoginWithVerifierForCertificateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginWithVerifierForCertificateResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &LoginResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *LoginWithVerifierForCertificateResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *LoginWithVerifierForCertificateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("loginWithVerifierForCertificate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginWithVerifierForCertificateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *LoginWithVerifierForCertificateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *LoginWithVerifierForCertificateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginWithVerifierForCertificateResult(%+v)", *p)
}

type LeaveGroupArgs struct {
	ReqSeq  int32  `thrift:"reqSeq,1" json:"reqSeq"`
	GroupId string `thrift:"groupId,2" json:"groupId"`
}

func NewLeaveGroupArgs() *LeaveGroupArgs {
	return &LeaveGroupArgs{}
}

func (p *LeaveGroupArgs) GetReqSeq() int32 {
	return p.ReqSeq
}

func (p *LeaveGroupArgs) GetGroupId() string {
	return p.GroupId
}
func (p *LeaveGroupArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LeaveGroupArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ReqSeq = v
	}
	return nil
}

func (p *LeaveGroupArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *LeaveGroupArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("leaveGroup_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LeaveGroupArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reqSeq", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:reqSeq: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ReqSeq)); err != nil {
		return fmt.Errorf("%T.reqSeq (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:reqSeq: %s", p, err)
	}
	return err
}

func (p *LeaveGroupArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:groupId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:groupId: %s", p, err)
	}
	return err
}

func (p *LeaveGroupArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LeaveGroupArgs(%+v)", *p)
}

type LeaveGroupResult struct {
	E *TalkException `thrift:"e,1" json:"e"`
}

func NewLeaveGroupResult() *LeaveGroupResult {
	return &LeaveGroupResult{}
}

var LeaveGroupResult_E_DEFAULT *TalkException

func (p *LeaveGroupResult) GetE() *TalkException {
	if !p.IsSetE() {
		return LeaveGroupResult_E_DEFAULT
	}
	return p.E
}
func (p *LeaveGroupResult) IsSetE() bool {
	return p.E != nil
}

func (p *LeaveGroupResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LeaveGroupResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *LeaveGroupResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("leaveGroup_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LeaveGroupResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *LeaveGroupResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LeaveGroupResult(%+v)", *p)
}

type LeaveRoomArgs struct {
	ReqSeq int32  `thrift:"reqSeq,1" json:"reqSeq"`
	RoomId string `thrift:"roomId,2" json:"roomId"`
}

func NewLeaveRoomArgs() *LeaveRoomArgs {
	return &LeaveRoomArgs{}
}

func (p *LeaveRoomArgs) GetReqSeq() int32 {
	return p.ReqSeq
}

func (p *LeaveRoomArgs) GetRoomId() string {
	return p.RoomId
}
func (p *LeaveRoomArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LeaveRoomArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ReqSeq = v
	}
	return nil
}

func (p *LeaveRoomArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.RoomId = v
	}
	return nil
}

func (p *LeaveRoomArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("leaveRoom_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LeaveRoomArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reqSeq", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:reqSeq: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ReqSeq)); err != nil {
		return fmt.Errorf("%T.reqSeq (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:reqSeq: %s", p, err)
	}
	return err
}

func (p *LeaveRoomArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("roomId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:roomId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.RoomId)); err != nil {
		return fmt.Errorf("%T.roomId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:roomId: %s", p, err)
	}
	return err
}

func (p *LeaveRoomArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LeaveRoomArgs(%+v)", *p)
}

type LeaveRoomResult struct {
	E *TalkException `thrift:"e,1" json:"e"`
}

func NewLeaveRoomResult() *LeaveRoomResult {
	return &LeaveRoomResult{}
}

var LeaveRoomResult_E_DEFAULT *TalkException

func (p *LeaveRoomResult) GetE() *TalkException {
	if !p.IsSetE() {
		return LeaveRoomResult_E_DEFAULT
	}
	return p.E
}
func (p *LeaveRoomResult) IsSetE() bool {
	return p.E != nil
}

func (p *LeaveRoomResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LeaveRoomResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *LeaveRoomResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("leaveRoom_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LeaveRoomResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *LeaveRoomResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LeaveRoomResult(%+v)", *p)
}

type GetProfileArgs struct {
}

func NewGetProfileArgs() *GetProfileArgs {
	return &GetProfileArgs{}
}

func (p *GetProfileArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetProfileArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getProfile_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetProfileArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetProfileArgs(%+v)", *p)
}

type GetProfileResult struct {
	Success *Profile       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewGetProfileResult() *GetProfileResult {
	return &GetProfileResult{}
}

var GetProfileResult_Success_DEFAULT *Profile

func (p *GetProfileResult) GetSuccess() *Profile {
	if !p.IsSetSuccess() {
		return GetProfileResult_Success_DEFAULT
	}
	return p.Success
}

var GetProfileResult_E_DEFAULT *TalkException

func (p *GetProfileResult) GetE() *TalkException {
	if !p.IsSetE() {
		return GetProfileResult_E_DEFAULT
	}
	return p.E
}
func (p *GetProfileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetProfileResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetProfileResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetProfileResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Profile{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetProfileResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetProfileResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getProfile_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetProfileResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetProfileResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetProfileResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetProfileResult(%+v)", *p)
}

type RejectGroupInvitationArgs struct {
	ReqSeq  int32  `thrift:"reqSeq,1" json:"reqSeq"`
	GroupId string `thrift:"groupId,2" json:"groupId"`
}

func NewRejectGroupInvitationArgs() *RejectGroupInvitationArgs {
	return &RejectGroupInvitationArgs{}
}

func (p *RejectGroupInvitationArgs) GetReqSeq() int32 {
	return p.ReqSeq
}

func (p *RejectGroupInvitationArgs) GetGroupId() string {
	return p.GroupId
}
func (p *RejectGroupInvitationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RejectGroupInvitationArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ReqSeq = v
	}
	return nil
}

func (p *RejectGroupInvitationArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *RejectGroupInvitationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rejectGroupInvitation_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RejectGroupInvitationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reqSeq", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:reqSeq: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ReqSeq)); err != nil {
		return fmt.Errorf("%T.reqSeq (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:reqSeq: %s", p, err)
	}
	return err
}

func (p *RejectGroupInvitationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:groupId: %s", p, err)
	}
	if err := oprot.WriteString(string(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:groupId: %s", p, err)
	}
	return err
}

func (p *RejectGroupInvitationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RejectGroupInvitationArgs(%+v)", *p)
}

type RejectGroupInvitationResult struct {
	E *TalkException `thrift:"e,1" json:"e"`
}

func NewRejectGroupInvitationResult() *RejectGroupInvitationResult {
	return &RejectGroupInvitationResult{}
}

var RejectGroupInvitationResult_E_DEFAULT *TalkException

func (p *RejectGroupInvitationResult) GetE() *TalkException {
	if !p.IsSetE() {
		return RejectGroupInvitationResult_E_DEFAULT
	}
	return p.E
}
func (p *RejectGroupInvitationResult) IsSetE() bool {
	return p.E != nil
}

func (p *RejectGroupInvitationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RejectGroupInvitationResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *RejectGroupInvitationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rejectGroupInvitation_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RejectGroupInvitationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *RejectGroupInvitationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RejectGroupInvitationResult(%+v)", *p)
}

type SendMessageArgs struct {
	Seq     int32    `thrift:"seq,1" json:"seq"`
	Message *Message `thrift:"message,2" json:"message"`
}

func NewSendMessageArgs() *SendMessageArgs {
	return &SendMessageArgs{}
}

func (p *SendMessageArgs) GetSeq() int32 {
	return p.Seq
}

var SendMessageArgs_Message_DEFAULT *Message

func (p *SendMessageArgs) GetMessage() *Message {
	if !p.IsSetMessage() {
		return SendMessageArgs_Message_DEFAULT
	}
	return p.Message
}
func (p *SendMessageArgs) IsSetMessage() bool {
	return p.Message != nil
}

func (p *SendMessageArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SendMessageArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Seq = v
	}
	return nil
}

func (p *SendMessageArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Message = &Message{}
	if err := p.Message.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Message, err)
	}
	return nil
}

func (p *SendMessageArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("sendMessage_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SendMessageArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("seq", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:seq: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Seq)); err != nil {
		return fmt.Errorf("%T.seq (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:seq: %s", p, err)
	}
	return err
}

func (p *SendMessageArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:message: %s", p, err)
	}
	if err := p.Message.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Message, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:message: %s", p, err)
	}
	return err
}

func (p *SendMessageArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SendMessageArgs(%+v)", *p)
}

type SendMessageResult struct {
	Success *Message       `thrift:"success,0" json:"success"`
	E       *TalkException `thrift:"e,1" json:"e"`
}

func NewSendMessageResult() *SendMessageResult {
	return &SendMessageResult{}
}

var SendMessageResult_Success_DEFAULT *Message

func (p *SendMessageResult) GetSuccess() *Message {
	if !p.IsSetSuccess() {
		return SendMessageResult_Success_DEFAULT
	}
	return p.Success
}

var SendMessageResult_E_DEFAULT *TalkException

func (p *SendMessageResult) GetE() *TalkException {
	if !p.IsSetE() {
		return SendMessageResult_E_DEFAULT
	}
	return p.E
}
func (p *SendMessageResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendMessageResult) IsSetE() bool {
	return p.E != nil
}

func (p *SendMessageResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SendMessageResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Message{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *SendMessageResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *SendMessageResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("sendMessage_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SendMessageResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SendMessageResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SendMessageResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SendMessageResult(%+v)", *p)
}

type UpdateContactSettingArgs struct {
	ReqSeq int32          `thrift:"reqSeq,1" json:"reqSeq"`
	Mid    string         `thrift:"mid,2" json:"mid"`
	Flag   ContactSetting `thrift:"flag,3" json:"flag"`
	Value  string         `thrift:"value,4" json:"value"`
}

func NewUpdateContactSettingArgs() *UpdateContactSettingArgs {
	return &UpdateContactSettingArgs{}
}

func (p *UpdateContactSettingArgs) GetReqSeq() int32 {
	return p.ReqSeq
}

func (p *UpdateContactSettingArgs) GetMid() string {
	return p.Mid
}

func (p *UpdateContactSettingArgs) GetFlag() ContactSetting {
	return p.Flag
}

func (p *UpdateContactSettingArgs) GetValue() string {
	return p.Value
}
func (p *UpdateContactSettingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateContactSettingArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ReqSeq = v
	}
	return nil
}

func (p *UpdateContactSettingArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Mid = v
	}
	return nil
}

func (p *UpdateContactSettingArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ContactSetting(v)
		p.Flag = temp
	}
	return nil
}

func (p *UpdateContactSettingArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *UpdateContactSettingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateContactSetting_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateContactSettingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reqSeq", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:reqSeq: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ReqSeq)); err != nil {
		return fmt.Errorf("%T.reqSeq (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:reqSeq: %s", p, err)
	}
	return err
}

func (p *UpdateContactSettingArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:mid: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Mid)); err != nil {
		return fmt.Errorf("%T.mid (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:mid: %s", p, err)
	}
	return err
}

func (p *UpdateContactSettingArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flag", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:flag: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Flag)); err != nil {
		return fmt.Errorf("%T.flag (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:flag: %s", p, err)
	}
	return err
}

func (p *UpdateContactSettingArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *UpdateContactSettingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateContactSettingArgs(%+v)", *p)
}

type UpdateContactSettingResult struct {
	E *TalkException `thrift:"e,1" json:"e"`
}

func NewUpdateContactSettingResult() *UpdateContactSettingResult {
	return &UpdateContactSettingResult{}
}

var UpdateContactSettingResult_E_DEFAULT *TalkException

func (p *UpdateContactSettingResult) GetE() *TalkException {
	if !p.IsSetE() {
		return UpdateContactSettingResult_E_DEFAULT
	}
	return p.E
}
func (p *UpdateContactSettingResult) IsSetE() bool {
	return p.E != nil
}

func (p *UpdateContactSettingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateContactSettingResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &TalkException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *UpdateContactSettingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateContactSetting_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateContactSettingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *UpdateContactSettingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateContactSettingResult(%+v)", *p)
}
